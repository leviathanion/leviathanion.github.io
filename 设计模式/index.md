# 设计模式

# 设计模式
## 设计原则
* 开闭原则
    * 对扩展开放
    * 对修改关闭
> 通过扩展来实现变化，而不是通过修改已有代码来实现变化
* 里氏替换原则
    * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
    * 子类可以有自己独有的方法
    * 覆盖或实现父类的方法时，输入参数可以被放大，更宽松
    * 覆盖或实现父类的方法时，输出参数可以被缩小，更严格
> 保证将所有父类替换为子类，程序的运行没有任何问题
* 迪米特原则
    * 一个对象应该对其他对象保持最少的了解
    * 只与直接的朋友通信
> 高内聚，只暴露接口，且不跨多级调用
* 单一职责原则：一个类只负责一项指责
> 当一个类负责太多指责时，会有多个原因导致类的变更，影响开发
* 接口分离原则
    * 客户端不应该依赖他不需要的接口
    * 类间的依赖关系建立在最小的接口上
> * 细化，建立单一指责的接口
> * 要适度细化，接口太小也会造成模型的复杂
* 依赖倒置原则
    * 高层模块（稳定）不应该依赖于底层模块（不稳定），二者都应该依赖于抽象（稳定）
    * 抽象（稳定）不应该依赖于实现细节（不稳定），实现细节应该依赖于抽象（稳定）
* 组合聚合复用原则
    * 尽量使用组合/聚合来复用
    * 减少继承的使用
## 常用设计模式
* 工厂模式：工厂模式是模板方法的一个特殊形式
* 建造者模式
* 单例模式
* 观察者模式
    * 发布者：将自身状态通知给其他对象
    * 订阅者：关注发布者状态变化的对象
> 实现
> * 订阅者：实现一个统一的通知接口。
> * 发布者
>   * 存储订阅对象引用的成员变量（一般定义一个独立的EventManager类来管理订阅者和其关心的消息，使用hashmap来实现）
>   * 添加和删除订阅者的共有方法
>   * 一个通知方法，调用订阅者的通知接口

> 与发布订阅模式的区别
> * 在观察者模式中，发布者维护观察者列表，而发布订阅模式，使用中间层进行消息代理，二者不互相依赖
> * 观察者模式以同步方式进行消息传递，发布订阅模式主要使用异步方式（消息队列）
> * 观察者模式往往是同一应用，而发布订阅模式可以跨应用访问
* 模板方法
    * 将算法分解为一系列步骤，并进行实现，在“模板方法”中依次调用这些步骤
    * 步骤可以是抽象的,也可以是默认的一些实现
    * 子类继承模板方法，并实现抽象步骤或者重写一些步骤
* 策略模式
    * 定义策略接口让策略类去实现
    * 定义一个上下文类来利用各种策略
    * 上下文类应该首先设置策略类，然后执行方法
* 代理模式
    * 在不改变原有类的基础上，增强其功能
    * 静态代理
        * 定义代理类
        * 实现增强的功能
        * 在代理类内部new出被代理的对象
    * 动态代理
        * JDK代理，通过其对应的接口，利用反射来实例化被代理类
        * cglib代理，生成一个被代理类的子类来拦截被代理的方法





